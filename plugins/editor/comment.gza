-- plugins/editor/comment.gza
-- Lightweight comment toggling helpers with lazy-load friendly commands.

local core = require("core")

local plugin = {
    name = "comment",
    state = {
        adapter = nil,
        scratch = {
            lines = { "" },
            filetype = "default",
            cursor = 1,
        },
        commands_registered = false,
    },
}

local comment_map = {
    lua = { line = "--", block = { "--[[", "]]" } },
    zig = { line = "//", block = { "/*", "*/" } },
    rust = { line = "//", block = { "/*", "*/" } },
    c = { line = "//", block = { "/*", "*/" } },
    cpp = { line = "//", block = { "/*", "*/" } },
    javascript = { line = "//", block = { "/*", "*/" } },
    typescript = { line = "//", block = { "/*", "*/" } },
    json = { line = "//" },
    toml = { line = "#" },
    yaml = { line = "#" },
    python = { line = "#" },
    sh = { line = "#" },
    bash = { line = "#" },
    md = { line = "<!--", block = { "<!--", "-->" } },
    markdown = { line = "<!--", block = { "<!--", "-->" } },
    html = { line = "<!--", block = { "<!--", "-->" } },
    css = { line = "//", block = { "/*", "*/" } },
    default = { line = "//", block = { "/*", "*/" } },
}

local function log(message)
    print("[comment] " .. message)
end

local function escape_pattern(text)
    return (text or ""):gsub("(%W)", "%%%1")
end

local function clone_lines(lines)
    local copy = {}
    for index, value in ipairs(lines or {}) do
        copy[index] = value
    end
    return copy
end

local function call_bridge(method, ...)
    local bridge = core.bridge and core.bridge()
    if type(bridge) == "table" then
        local fn = bridge[method]
        if type(fn) == "function" then
            local ok, result = pcall(fn, ...)
            if ok then
                return result
            end
        end
    end
    return nil
end

local function ensure_scratch()
    local scratch = plugin.state.scratch
    scratch.lines = scratch.lines or { "" }
    scratch.filetype = scratch.filetype or "default"
    scratch.cursor = scratch.cursor or 1
    return scratch
end

local function make_adapter()
    local adapter = {}

    function adapter.filetype()
        local ft = call_bridge("buffer_filetype")
        if type(ft) == "string" and #ft > 0 then
            return ft
        end
        local getter = rawget(_G, "buffer_filetype")
        if type(getter) == "function" then
            local ok, value = pcall(getter)
            if ok and type(value) == "string" and #value > 0 then
                return value
            end
        end
        return ensure_scratch().filetype
    end

    function adapter.cursor_line()
        local cursor = call_bridge("buffer_cursor")
        if type(cursor) == "table" and type(cursor.line) == "number" then
            return cursor.line
        elseif type(cursor) == "number" then
            return cursor
        end
        local getter = rawget(_G, "buffer_cursor")
        if type(getter) == "function" then
            local ok, value = pcall(getter)
            if ok then
                if type(value) == "table" and type(value.line) == "number" then
                    return value.line
                elseif type(value) == "number" then
                    return value
                end
            end
        end
        return ensure_scratch().cursor
    end

    function adapter.set_cursor(line)
        if type(line) ~= "number" then
            return
        end
        local setter = rawget(_G, "buffer_set_cursor")
        if type(setter) == "function" then
            local ok = pcall(setter, line)
            if ok then
                return
            end
        end
        ensure_scratch().cursor = line
    end

    function adapter.get_lines(start_line, end_line)
        local lines = call_bridge("buffer_get_lines", start_line, end_line)
        if type(lines) == "table" then
            return lines
        end
        local getter = rawget(_G, "buffer_get_lines")
        if type(getter) == "function" then
            local ok, value = pcall(getter, start_line, end_line)
            if ok and type(value) == "table" then
                return value
            end
        end

        local scratch = ensure_scratch()
        local result = {}
        for line = start_line, end_line do
            result[#result + 1] = scratch.lines[line] or ""
        end
        return result
    end

    function adapter.set_lines(start_line, end_line, lines)
        local setter = rawget(_G, "buffer_set_lines")
        if type(setter) == "function" then
            local ok = pcall(setter, start_line, end_line, lines)
            if ok then
                return true
            end
        end

        local scratch = ensure_scratch()
        for index = end_line, start_line, -1 do
            table.remove(scratch.lines, index)
        end
        for offset = 1, #(lines or {}) do
            table.insert(scratch.lines, start_line + offset - 1, lines[offset])
        end
        return true
    end

    return adapter
end

local function adapter()
    if not plugin.state.adapter then
        plugin.state.adapter = make_adapter()
    end
    return plugin.state.adapter
end

local function resolve_comment_tokens(filetype)
    if type(filetype) ~= "string" or #filetype == 0 then
        filetype = "default"
    end

    local tokens = comment_map[filetype]
    if tokens then
        return tokens
    end

    -- Try stripping subtypes (e.g., "javascriptreact" -> "javascript").
    for key, value in pairs(comment_map) do
        if key ~= "default" and filetype:find(key, 1, true) then
            return value
        end
    end

    return comment_map.default
end

local function toggle_line_text(line, comment_token)
    local indent, body = line:match("^(%s*)(.-)$")
    indent = indent or ""
    body = body or ""

    if #body == 0 then
        return indent .. comment_token, "comment"
    end

    local pattern = "^" .. escape_pattern(comment_token) .. "%s?"
    if body:match(pattern) then
        local stripped = body:gsub(pattern, "", 1)
        return indent .. stripped, "uncomment"
    end

    return indent .. comment_token .. " " .. body, "comment"
end

local function toggle_line(line_nr)
    local line = adapter().get_lines(line_nr, line_nr)[1]
    if line == nil then
        return false
    end

    local tokens = resolve_comment_tokens(adapter().filetype())
    local new_line, action = toggle_line_text(line, tokens.line)
    adapter().set_lines(line_nr, line_nr, { new_line })
    return action == "comment", action
end

local function toggle_block_lines(start_line, end_line)
    if start_line > end_line then
        start_line, end_line = end_line, start_line
    end

    local tokens = resolve_comment_tokens(adapter().filetype())
    local block_tokens = tokens.block
    if not block_tokens or #block_tokens < 2 then
        local changed = false
        for line = start_line, end_line do
            local commented = toggle_line(line)
            changed = changed or commented
        end
        return changed and "comment" or "uncomment"
    end

    local lines = adapter().get_lines(start_line, end_line)
    if #lines == 0 then
        return "noop"
    end

    local first_trim = lines[1]:match("^%s*(.-)%s*$") or ""
    local last_trim = lines[#lines]:match("^%s*(.-)%s*$") or ""
    local start_token = block_tokens[1]
    local end_token = block_tokens[2]

    if first_trim == start_token and last_trim == end_token then
        local new_lines = {}
        for index = 2, #lines - 1 do
            new_lines[#new_lines + 1] = lines[index]
        end
        adapter().set_lines(start_line, end_line, new_lines)
        return "uncomment"
    end

    local start_indent = lines[1]:match("^(%s*)") or ""
    local end_indent = lines[#lines]:match("^(%s*)") or ""

    local new_lines = { start_indent .. start_token }
    for _, value in ipairs(lines) do
        new_lines[#new_lines + 1] = value
    end
    new_lines[#new_lines + 1] = end_indent .. end_token

    adapter().set_lines(start_line, end_line, new_lines)
    return "comment"
end

local function parse_args(ctx)
    if type(ctx) == "string" then
        local result = {}
        for token in ctx:gmatch("%S+") do
            result[#result + 1] = token
        end
        return result
    end
    if type(ctx) == "table" then
        if type(ctx.args) == "string" then
            return parse_args(ctx.args)
        end
        local result = {}
        local index = 1
        while ctx[index] do
            if type(ctx[index]) == "string" and #ctx[index] > 0 then
                result[#result + 1] = ctx[index]
            end
            index = index + 1
        end
        return result
    end
    return {}
end

local function register_command(name, fn, desc)
    if type(command) ~= "function" then
        return
    end
    local ok, err = pcall(command, name, fn, { desc = desc })
    if not ok then
        log("failed to register command " .. tostring(name) .. ": " .. tostring(err))
    end
end

local function register_commands()
    if plugin.state.commands_registered then
        return
    end

    register_command("CommentToggle", function(ctx)
        local args = parse_args(ctx)
        local line = tonumber(args[1]) or adapter().cursor_line()
        local _, action = toggle_line(line)
        log(string.format("line %d %s", line, action))
    end, "Toggle comment for current line")

    register_command("CommentLine", function(ctx)
        local args = parse_args(ctx)
        local target = tonumber(args[1]) or adapter().cursor_line()
        toggle_line(target)
    end, "Toggle comment on a specific line")

    register_command("CommentBlock", function(ctx)
        local args = parse_args(ctx)
        local start_line = tonumber(args[1]) or adapter().cursor_line()
        local end_line = tonumber(args[2]) or start_line
        local action = toggle_block_lines(start_line, end_line)
        log(string.format("block %d-%d %s", start_line, end_line, action))
    end, "Toggle block comments over a range")

    plugin.state.commands_registered = true
end

function plugin.toggle_line(line)
    local target = tonumber(line) or adapter().cursor_line()
    return toggle_line(target)
end

function plugin.toggle_block(start_line, end_line)
    return toggle_block_lines(tonumber(start_line) or adapter().cursor_line(), tonumber(end_line) or adapter().cursor_line())
end

function plugin.configure(opts)
    opts = opts or {}
    if opts.adapter and type(opts.adapter) == "table" then
        plugin.state.adapter = opts.adapter
    end
    if opts.scratch then
        plugin.set_scratch(opts.scratch)
    end
    register_commands()
    return plugin
end

function plugin.set_scratch(opts)
    local scratch = ensure_scratch()
    if opts.lines then
        scratch.lines = clone_lines(opts.lines)
    end
    scratch.filetype = opts.filetype or scratch.filetype
    scratch.cursor = opts.cursor or scratch.cursor
    return scratch
end

function plugin.summary()
    return {
        filetype = adapter().filetype(),
        cursor = adapter().cursor_line(),
    }
end

return plugin.configure()
