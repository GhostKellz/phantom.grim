-- plugins/editor/comment.gza
-- Lightweight comment toggling helpers with lazy-load friendly commands.

local textops = require("plugins.editor.textops")

local plugin = {
    name = "comment",
    state = {
        commands_registered = false,
        last_repeat = nil,
    },
}

local comment_map = {
    lua = { line = "--", block = { "--[[", "]]" } },
    zig = { line = "//", block = { "/*", "*/" } },
    rust = { line = "//", block = { "/*", "*/" } },
    c = { line = "//", block = { "/*", "*/" } },
    cpp = { line = "//", block = { "/*", "*/" } },
    javascript = { line = "//", block = { "/*", "*/" } },
    typescript = { line = "//", block = { "/*", "*/" } },
    json = { line = "//" },
    toml = { line = "#" },
    yaml = { line = "#" },
    python = { line = "#" },
    sh = { line = "#" },
    bash = { line = "#" },
    md = { line = "<!--", block = { "<!--", "-->" } },
    markdown = { line = "<!--", block = { "<!--", "-->" } },
    html = { line = "<!--", block = { "<!--", "-->" } },
    css = { line = "//", block = { "/*", "*/" } },
    default = { line = "//", block = { "/*", "*/" } },
}

local function log(message)
    print("[comment] " .. message)
end

local function escape_pattern(text)
    return (text or ""):gsub("(%W)", "%%%1")
end

local function resolve_comment_tokens(filetype)
    if type(filetype) ~= "string" or #filetype == 0 then
        filetype = "default"
    end

    local tokens = comment_map[filetype]
    if tokens then
        return tokens
    end

    -- Try stripping subtypes (e.g., "javascriptreact" -> "javascript").
    for key, value in pairs(comment_map) do
        if key ~= "default" and filetype:find(key, 1, true) then
            return value
        end
    end

    return comment_map.default
end

local function toggle_line_text(line, comment_token)
    local indent, body = line:match("^(%s*)(.-)$")
    indent = indent or ""
    body = body or ""

    if #body == 0 then
        return indent .. comment_token, "comment"
    end

    local pattern = "^" .. escape_pattern(comment_token) .. "%s?"
    if body:match(pattern) then
        local stripped = body:gsub(pattern, "", 1)
        return indent .. stripped, "uncomment"
    end

    return indent .. comment_token .. " " .. body, "comment"
end

local function toggle_line(line_nr)
    local line = textops.get_lines(line_nr, line_nr)[1]
    if line == nil then
        return false
    end

    local tokens = resolve_comment_tokens(textops.filetype())
    local new_line, action = toggle_line_text(line, tokens.line)
    textops.set_line(line_nr, new_line)
    return action == "comment", action
end

local function toggle_block_lines(start_line, end_line)
    if start_line > end_line then
        start_line, end_line = end_line, start_line
    end

    local tokens = resolve_comment_tokens(textops.filetype())
    local block_tokens = tokens.block
    if not block_tokens or #block_tokens < 2 then
        local changed = false
        for line = start_line, end_line do
            local commented = toggle_line(line)
            changed = changed or commented
        end
        return changed and "comment" or "uncomment"
    end

    local lines = textops.get_lines(start_line, end_line)
    if #lines == 0 then
        return "noop"
    end

    local first_trim = lines[1]:match("^%s*(.-)%s*$") or ""
    local last_trim = lines[#lines]:match("^%s*(.-)%s*$") or ""
    local start_token = block_tokens[1]
    local end_token = block_tokens[2]

    if first_trim == start_token and last_trim == end_token then
        local new_lines = {}
        for index = 2, #lines - 1 do
            new_lines[#new_lines + 1] = lines[index]
        end
        textops.replace_lines(start_line, end_line, new_lines)
        return "uncomment"
    end

    local start_indent = lines[1]:match("^(%s*)") or ""
    local end_indent = lines[#lines]:match("^(%s*)") or ""

    local new_lines = { start_indent .. start_token }
    for _, value in ipairs(lines) do
        new_lines[#new_lines + 1] = value
    end
    new_lines[#new_lines + 1] = end_indent .. end_token

    textops.replace_lines(start_line, end_line, new_lines)
    return "comment"
end

local function parse_args(ctx)
    if type(ctx) == "string" then
        local result = {}
        for token in ctx:gmatch("%S+") do
            result[#result + 1] = token
        end
        return result
    end
    if type(ctx) == "table" then
        if type(ctx.args) == "string" then
            return parse_args(ctx.args)
        end
        local result = {}
        local index = 1
        while ctx[index] do
            if type(ctx[index]) == "string" and #ctx[index] > 0 then
                result[#result + 1] = ctx[index]
            end
            index = index + 1
        end
        return result
    end
    return {}
end

local function register_command(name, fn, desc)
    if type(command) ~= "function" then
        return
    end
    local ok, err = pcall(command, name, fn, { desc = desc })
    if not ok then
        log("failed to register command " .. tostring(name) .. ": " .. tostring(err))
    end
end

local function register_commands()
    if plugin.state.commands_registered then
        return
    end

    register_command("CommentToggle", function(ctx)
        local args = parse_args(ctx)
        local line = tonumber(args[1]) or select(1, textops.cursor())
        local _, action = toggle_line(line)
        log(string.format("line %d %s", line, action))
    end, "Toggle comment for current line")

    register_command("CommentLine", function(ctx)
        local args = parse_args(ctx)
        local target = tonumber(args[1]) or select(1, textops.cursor())
        toggle_line(target)
    end, "Toggle comment on a specific line")

    register_command("CommentBlock", function(ctx)
        local args = parse_args(ctx)
        local start_line = tonumber(args[1]) or select(1, textops.cursor())
        local end_line = tonumber(args[2]) or start_line
        local action = toggle_block_lines(start_line, end_line)
        log(string.format("block %d-%d %s", start_line, end_line, action))
    end, "Toggle block comments over a range")

    register_command("CommentRepeat", function()
        if type(plugin.state.last_repeat) == "function" then
            plugin.state.last_repeat()
        end
    end, "Repeat last comment action")

    plugin.state.commands_registered = true
end

local function record_repeat(kind, action)
    local operator_api = textops.operator_api()
    if operator_api then
        if type(operator_api.recordOperation) == "function" then
            local ok = pcall(operator_api.recordOperation, operator_api, kind, action.range or {}, action.result or "", 1, nil)
            if ok then
                plugin.state.last_repeat = function()
                    pcall(action.callback)
                end
                return
            end
        elseif type(operator_api.record_operation) == "function" then
            local ok = pcall(operator_api.record_operation, operator_api, kind, action.range or {}, action.result or "", 1, nil)
            if ok then
                plugin.state.last_repeat = function()
                    pcall(action.callback)
                end
                return
            end
        end
    end

    plugin.state.last_repeat = function()
        pcall(action.callback)
    end
end

function plugin.toggle_line(line)
    local target = tonumber(line) or select(1, textops.cursor())
    local _, action = toggle_line(target)
    record_repeat("comment-line", {
        range = { line = target },
        result = action,
        callback = function()
            toggle_line(target)
        end,
    })
end

function plugin.toggle_block(start_line, end_line)
    local line = tonumber(start_line) or select(1, textops.cursor())
    local finish = tonumber(end_line) or select(1, textops.cursor())
    local action = toggle_block_lines(line, finish)
    record_repeat("comment-block", {
        range = { start = line, finish = finish },
        result = action,
        callback = function()
            toggle_block_lines(line, finish)
        end,
    })
end

function plugin.configure(opts)
    opts = opts or {}
    if opts.scratch then
        textops.set_scratch(opts.scratch)
    end
    if opts.filetype then
        textops.set_filetype(opts.filetype)
    end
    register_commands()
    return plugin
end

function plugin.set_scratch(opts)
    return textops.set_scratch(opts)
end

function plugin.summary()
    local line, col = textops.cursor()
    return {
        filetype = textops.filetype(),
        cursor_line = line,
        cursor_col = col,
    }
end

return plugin.configure()
